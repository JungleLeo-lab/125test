<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AR 3D模型查看器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        }
        
        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            transform: scaleX(-1); /* 镜像翻转，使画面更自然 */
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 10;
            max-width: 300px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 12px 24px;
            background: rgba(0, 122, 255, 0.9);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            font-weight: 600;
        }
        
        button:active {
            background: rgba(0, 122, 255, 0.7);
        }
        
        #status {
            margin-top: 10px;
            color: #ff9500;
        }
        
        .error {
            color: #ff3b30;
        }
        
        .success {
            color: #34c759;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
        <div id="info">
            <div>AR 3D模型查看器</div>
            <div id="status">正在初始化...</div>
            <div id="orientation">陀螺仪: 等待数据</div>
            <div id="camera">摄像头: 等待启动</div>
        </div>
        <div id="controls">
            <button id="startBtn">开始AR</button>
            <button id="resetBtn">重置视角</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // OBJLoader (简化版本)
        THREE.OBJLoader = function() {};
        
        THREE.OBJLoader.prototype.load = function(url, onLoad, onProgress, onError) {
            const scope = this;
            const xhr = new XMLHttpRequest();
            
            xhr.onload = function() {
                if (xhr.status === 200 || xhr.status === 0) {
                    try {
                        const object = scope.parse(xhr.responseText || xhr.response);
                        if (onLoad) onLoad(object);
                    } catch (e) {
                        if (onError) {
                            onError(e);
                        } else {
                            console.error('解析OBJ文件错误:', e);
                        }
                    }
                } else {
                    if (onError) {
                        onError(new Error('HTTP错误: ' + xhr.status));
                    }
                }
            };
            
            xhr.onerror = function() {
                if (onError) {
                    onError(new Error('加载OBJ文件失败'));
                }
            };
            
            xhr.onprogress = function(event) {
                if (onProgress && event.lengthComputable) {
                    onProgress(event);
                }
            };
            
            xhr.open('GET', url, true);
            xhr.send(null);
        };
        
        THREE.OBJLoader.prototype.parse = function(text) {
            const lines = text.split('\n');
            const vertices = [];
            const normals = [];
            const uvs = [];
            const faces = [];
            const object = new THREE.Group();
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.length === 0 || line.charAt(0) === '#') continue;
                
                const parts = line.split(/\s+/);
                const type = parts[0];
                
                if (type === 'v') {
                    vertices.push(
                        parseFloat(parts[1]),
                        parseFloat(parts[2]),
                        parseFloat(parts[3])
                    );
                } else if (type === 'vn') {
                    normals.push(
                        parseFloat(parts[1]),
                        parseFloat(parts[2]),
                        parseFloat(parts[3])
                    );
                } else if (type === 'vt') {
                    uvs.push(
                        parseFloat(parts[1]),
                        parseFloat(parts[2])
                    );
                } else if (type === 'f') {
                    const faceIndices = [];
                    for (let j = 1; j < parts.length; j++) {
                        const indices = parts[j].split('/');
                        faceIndices.push({
                            v: parseInt(indices[0]) - 1,
                            vt: indices[1] ? parseInt(indices[1]) - 1 : -1,
                            vn: indices[2] ? parseInt(indices[2]) - 1 : -1
                        });
                    }
                    faces.push(faceIndices);
                }
            }
            
            const positions = [];
            const normalsArray = [];
            const uvsArray = [];
            
            for (let i = 0; i < faces.length; i++) {
                const face = faces[i];
                for (let j = 1; j < face.length - 1; j++) {
                    const v0 = face[0];
                    const v1 = face[j];
                    const v2 = face[j + 1];
                    
                    positions.push(
                        vertices[v0.v * 3], vertices[v0.v * 3 + 1], vertices[v0.v * 3 + 2],
                        vertices[v1.v * 3], vertices[v1.v * 3 + 1], vertices[v1.v * 3 + 2],
                        vertices[v2.v * 3], vertices[v2.v * 3 + 1], vertices[v2.v * 3 + 2]
                    );
                    
                    if (v0.vn >= 0 && normals.length > 0) {
                        normalsArray.push(
                            normals[v0.vn * 3], normals[v0.vn * 3 + 1], normals[v0.vn * 3 + 2],
                            normals[v1.vn * 3], normals[v1.vn * 3 + 1], normals[v1.vn * 3 + 2],
                            normals[v2.vn * 3], normals[v2.vn * 3 + 1], normals[v2.vn * 3 + 2]
                        );
                    }
                    if (v0.vt >= 0 && uvs.length > 0) {
                        uvsArray.push(
                            uvs[v0.vt * 2], uvs[v0.vt * 2 + 1],
                            uvs[v1.vt * 2], uvs[v1.vt * 2 + 1],
                            uvs[v2.vt * 2], uvs[v2.vt * 2 + 1]
                        );
                    }
                }
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            if (normalsArray.length > 0) {
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normalsArray, 3));
            } else {
                geometry.computeVertexNormals();
            }
            
            if (uvsArray.length > 0) {
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvsArray, 2));
            }
            
            const material = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const mesh = new THREE.Mesh(geometry, material);
            object.add(mesh);
            
            return object;
        };
    </script>

    <script>
        // 全局变量
        let video, canvas, renderer, scene, camera, model;
        let videoTexture;
        let alpha = 0, beta = 0, gamma = 0;
        let isARActive = false;
        let orientationPermissionGranted = false;
        
        // 初始化
        function init() {
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            
            // 创建Three.js场景
            scene = new THREE.Scene();
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // 启动摄像头
            startCamera();
            
            // 加载3D模型
            loadModel();
            
            // 事件监听
            document.getElementById('startBtn').addEventListener('click', toggleAR);
            document.getElementById('resetBtn').addEventListener('click', resetView);
            
            window.addEventListener('resize', onWindowResize);
            
            // 开始渲染循环
            animate();
        }
        
        // 启动摄像头
        async function startCamera() {
            try {
                updateStatus('正在请求摄像头权限...', 'status');
                
                const constraints = {
                    video: {
                        facingMode: { ideal: 'environment' },
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                video.addEventListener('loadedmetadata', () => {
                    video.play();
                    updateStatus('摄像头已启动', 'camera', 'success');
                    
                    videoTexture = new THREE.VideoTexture(video);
                    videoTexture.minFilter = THREE.LinearFilter;
                    videoTexture.magFilter = THREE.LinearFilter;
                    videoTexture.flipY = true;
                    
                    const videoAspect = video.videoWidth / video.videoHeight;
                    const planeSize = 20;
                    const geometry = new THREE.PlaneGeometry(planeSize * videoAspect, planeSize);
                    const material = new THREE.MeshBasicMaterial({
                        map: videoTexture,
                        side: THREE.DoubleSide
                    });
                    const backgroundPlane = new THREE.Mesh(geometry, material);
                    backgroundPlane.position.set(0, 0, -10);
                    scene.add(backgroundPlane);
                });
                
            } catch (error) {
                console.error('摄像头错误:', error);
                updateStatus('摄像头启动失败: ' + error.message, 'camera', 'error');
            }
        }
        
        // 请求陀螺仪权限并启动
        async function requestOrientationPermission() {
            // iOS 13+ 需要用户交互才能请求权限
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        orientationPermissionGranted = true;
                        startOrientationListener();
                        updateStatus('陀螺仪权限已授予', 'orientation', 'success');
                        return true;
                    } else {
                        updateStatus('陀螺仪权限被拒绝', 'orientation', 'error');
                        return false;
                    }
                } catch (error) {
                    console.error('权限请求错误:', error);
                    updateStatus('权限请求失败: ' + error.message, 'orientation', 'error');
                    return false;
                }
            } else {
                // 非iOS 13+，直接启动
                orientationPermissionGranted = true;
                startOrientationListener();
                return true;
            }
        }
        
        // 启动方向监听
        function startOrientationListener() {
            // 移除旧的监听器（如果存在）
            window.removeEventListener('deviceorientation', handleOrientation);
            
            // 添加新的监听器
            window.addEventListener('deviceorientation', handleOrientation, true);
            
            updateStatus('正在监听陀螺仪数据...', 'orientation');
        }
        
        // 处理设备方向事件
        function handleOrientation(event) {
            // 检查数据是否有效
            if (event.alpha === null || event.beta === null || event.gamma === null) {
                updateStatus('陀螺仪数据无效', 'orientation', 'error');
                return;
            }
            
            alpha = event.alpha; // 0-360度
            beta = event.beta;   // -180到180度
            gamma = event.gamma; // -90到90度
            
            // 更新显示
            updateOrientationInfo();
            
            // 如果AR激活，更新相机旋转
            if (isARActive && model) {
                updateCameraRotation();
            }
        }
        
        // 更新相机旋转
        function updateCameraRotation() {
            if (!isARActive) return;
            
            const alphaRad = THREE.MathUtils.degToRad(alpha);
            const betaRad = THREE.MathUtils.degToRad(beta);
            const gammaRad = THREE.MathUtils.degToRad(gamma);
            
            // 将设备方向映射到相机旋转
            // 注意：可能需要根据实际效果调整这些映射
            camera.rotation.x = betaRad;
            camera.rotation.y = alphaRad;
            camera.rotation.z = -gammaRad;
        }
        
        // 加载3D模型
        function loadModel() {
            updateStatus('正在加载3D模型...', 'status');
            
            const loader = new THREE.OBJLoader();
            loader.load(
                './1.obj',
                function(object) {
                    model = object;
                    
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    model.position.sub(center);
                    
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 2 / maxDim;
                    model.scale.multiplyScalar(scale);
                    
                    model.position.set(0, 0, -5);
                    model.rotation.set(0, 0, 0);
                    
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                    scene.add(ambientLight);
                    
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(5, 5, 5);
                    scene.add(directionalLight);
                    
                    scene.add(model);
                    
                    updateStatus('3D模型加载成功', 'status', 'success');
                },
                function(progress) {
                    if (progress.total > 0) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(1);
                        updateStatus(`加载中: ${percent}%`, 'status');
                    }
                },
                function(error) {
                    console.error('模型加载错误:', error);
                    updateStatus('模型加载失败: ' + error.message, 'status', 'error');
                }
            );
        }
        
        // 切换AR模式
        async function toggleAR() {
            if (!isARActive) {
                // 请求陀螺仪权限
                const granted = await requestOrientationPermission();
                if (granted) {
                    isARActive = true;
                    document.getElementById('startBtn').textContent = '停止AR';
                    updateStatus('AR模式已激活', 'status', 'success');
                } else {
                    updateStatus('需要陀螺仪权限才能使用AR', 'status', 'error');
                }
            } else {
                isARActive = false;
                document.getElementById('startBtn').textContent = '开始AR';
                camera.rotation.set(0, 0, 0);
                updateStatus('AR模式已停止', 'status');
            }
        }
        
        // 重置视角
        function resetView() {
            camera.rotation.set(0, 0, 0);
            updateStatus('视角已重置', 'status', 'success');
        }
        
        // 更新状态信息
        function updateStatus(message, elementId, className = '') {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = message;
                element.className = className;
            }
        }
        
        // 更新方向信息
        function updateOrientationInfo() {
            const info = `α: ${alpha.toFixed(1)}° β: ${beta.toFixed(1)}° γ: ${gamma.toFixed(1)}°`;
            updateStatus(info, 'orientation', 'success');
        }
        
        // 窗口大小改变
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            if (videoTexture) {
                videoTexture.needsUpdate = true;
            }
            
            renderer.render(scene, camera);
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>
